import { Player } from "./player";
import { eventEmitter as emitter} from "../index";
var pokerEval = require('poker-evaluator');

export class Game {
	private _players : Array<Player> = [];
	private _id : string;
	private _deck : Array<number> = []; //generated by constructor
	private _table : Array<number> = []
	private _io;
	private _gameStage : number = 1; //flop, turn, river = 1, 2, 3
	private _pot : number;
	private _dealer : number = 0;

	public constructor(p1 : Player, p2 : Player, id : string, io) {
		p1.inGame = true;
		p2.inGame = true;
		this.addPlayer(p1);
		this.addPlayer(p2);
		this._io = io;
		this._id = id;
		p1.socket.join(id); //join the game's chat room
		p2.socket.join(id);
		if (io.sockets.adapter.rooms[id].length == 2) { //seems to work without a loop
			io.to(id).emit('game created', {names: [this._players[0].nickname, this._players[1].nickname], stacks: [p1.stack, p2.stack]});	
		}
		console.log("new game created with id " + id + " and players " + p1.id + ", " + p2.id);
		this.play();
	}

	public addPlayer(player : Player) {
		this._players.push(player);
	}

	get id() {
		return this._id;
	}

	public containsPlayer(id : string) : boolean {
		for (var i=0; i<this._players.length ;i++) {
			if (this._players[i].id === id) {
				return true;
			}
		}
		return false;
	}

	public stringifyHand(hand : Array<number>) : Array<string> {
		var stringHand = [];
		for (var i=0; i<hand.length; i++) {
			var card = "";
			var cardNumber = hand[i] % 13;
			var cardSuit = Math.floor(hand[i] / 13);

			if (cardNumber < 10 && cardNumber > 1) {
				card += cardNumber;
			}
			else if (cardNumber == 10) {
				card += "T";
			}
			else if (cardNumber == 11) {
				card += "J";
			}
			else if (cardNumber == 12) {
				card += "Q";
			}
			else if (cardNumber == 0) {
				card += "K";
			}
			else { //if 1
				card += "A";
			}

			if (cardSuit == 0) {
				card += "s";
			}
			else if (cardSuit == 1) {
				card += "d";				
			}
			else if (cardSuit == 2) {
				card += "c";
			}
			else {
				card += "h";
			}
			stringHand.push(card);
		}
		return stringHand;
	}

	public compareHands(p1Hand : Array<string>, p2Hand : Array<string>) {
		var p1Eval = pokerEval.evalHand(p1Hand);
		var p2Eval = pokerEval.evalHand(p2Hand);
		if (p1Eval.handType > p2Eval.handType) {
			return {result: 1, hand: p1Eval.handName};
		}
		else if (p2Eval.handType > p1Eval.handType) {
			return {result: 2, hand: p2Eval.handName};
		}
		else { //if the same hand type
			if (p1Eval.handRank > p2Eval.handRank) {
				return {result: 1, hand: p1Eval.handName};
			}
			else if (p2Eval.handRank > p1Eval.handRank) {
				return {result: 2, hand: p2Eval.handName};
			}
			else {
				return {result: 3, hand: p1Eval.handName}; //split pot
			}
		}
	}

	public newHand() {
		console.log('starting new hand');
		this._deck = []; //initialise deck
		for (var i=0; i<52; i++) {
			this._deck.push(i);
		}
		this._dealer = (this._dealer + 1) % 2; //change dealer
		this._table = []; //clear table
		for (var i=0; i<this._players.length; i++) {
			this._players[i].bet = 0;
		}
		this._gameStage = 1;
		this._pot = 0;
		this._io.to(this.id).emit('new hand', this._players[this._dealer].id);
		this.deal(); //deal new hole cards to players

		var dealer = this._players[this._dealer];
		var nonDealer = this._players[(this._dealer + 1) % 2];
		setTimeout(()=> {
			if (dealer.stack > 10) { //post blinds
				this.handleBet(10, dealer.id);
				if (nonDealer.stack > 20) {
					this.handleBet(20, nonDealer.id);
				}
				else {
					this.handleBet(nonDealer.stack, nonDealer.id);
				}
			}
			else {
				this.handleBet(dealer.stack, dealer.id);
			}
		}, 1000);
	}

	public getRandomCard() : number {
		var i = Math.floor(Math.random() * this._deck.length);
		return this._deck.splice(i, 1)[0];
	}

	public deal() {
		for (var i=0; i<this._players.length; i++) {
			var cards = [this.getRandomCard(), this.getRandomCard()];
			this._players[i].holeCards = cards;
			this._io.to(this._players[i].id).emit('hole cards', this.stringifyHand(cards));
		}
	}

	public handleBet(amount : number, id : string) {
		amount = Number(amount); //convert amount to number
		console.log("bet amount" + amount);
		for (var i=0; i<this._players.length; i++) {
			if (id == this._players[i].id) {
				this._players[i].bet = amount;
				var otherBet  = this._players[(i+1)%2].bet;
				var otherStack = this._players[(i+1)%2].stack;
				console.log("otherStack: " + otherStack);
				if (amount != 20) {
					if (2 * amount - otherBet < otherStack) {
						var min =  2 * amount - otherBet;
					}
					else {
						var min = otherStack;
					}
				}
				else {
					var min = 40;
				}
				this._io.to(this.id).emit('bet', {amount: amount, min: min, max: otherStack, pot: this._pot,  id: id, stack: (this._players[i].stack - amount), otherStack: otherStack, gameStage: this._gameStage});
			}
		}
	}

	public handleCall(id : string) { //even out bet amounts. To do: ensure a call by the small blind doesn't lead straight to flop
		if (this._players[0].bet > this._players[1].bet) {
			var a = this._players[0];
			var b = this._players[1];
		}
		else {
			var a = this._players[1];
			var b = this._players[0];
		}
		var allIn = false;
		if (a.bet >= b.stack) { //excess allocated to a
			b.bet = b.stack;
			var bet = b.bet;
			var excess = a.bet - b.bet;
			var excessWinner  = a ;
			allIn = true;
		}
		else if (a.bet == a.stack) { //b stack > a stack. no excess
			if (b.stack > a.stack) {
				b.bet = a.bet;
				var bet = b.bet;
			}
			allIn = true;
		}
		else {
			b.bet = a.bet;
			var bet = a.bet;
		}
		if (!(this._gameStage == 1 && !allIn && a.bet == 20)) {
			for (var i=0; i<this._players.length; i++) { //decrease stacks
				console.log("Player " + i + " stack changed by " + this._players[i].bet * -1);
				this._players[i].changeStack(this._players[i].bet * -1);
		}
		}
		for (var i=0; i<this._players.length; i++) {
			if (id == this._players[i].id) {
				var otherStack = this._players[(i+1)%2].stack;
				var calledStack = this._players[i].stack;
			}
		}

		console.log("Game stage: " + this._gameStage);
		if (this._gameStage == 1 && a.bet == 20 && !allIn) {
			this._io.to(this.id).emit('call', {amount: bet, pot: this._pot, min: (otherStack >= 40 ? 40 : otherStack), max: calledStack, otherMax: otherStack, id: id, dealer: this._players[this._dealer].id, checkable: true, stack: calledStack - 20});
		}
		else {
			var cardsToDeal = !allIn ? this.getCardsToDeal() : this.getCardsAllIn();
			this._gameStage += 1;
			this._pot += this._players[0].bet + this._players[1].bet;
			this._table = this._table.concat(cardsToDeal);
			this._io.to(this.id).emit('call', {amount: bet, pot: this._pot, cards: this.stringifyHand(cardsToDeal), min: (this._players[(this._dealer + 1) % 2].stack > 20 ? 20 : this._players[(this._dealer + 1) % 2].stack), max: calledStack, otherMax: otherStack, id: id, dealer: this._players[this._dealer].id, checkable: false, playingOn : (this._gameStage != 5 && !allIn), stack: calledStack}); //amount the same for both players so whose bet does not matter
			this._players[0].bet = 0; //reset bets
			this._players[1].bet = 0;

			if (this._gameStage == 5 || allIn) {
				var p1Hand = this.stringifyHand(this._players[0].holeCards.concat(this._table));
				var p2Hand = this.stringifyHand(this._players[1].holeCards.concat(this._table));
				var comparison = this.compareHands(p1Hand, p2Hand);
				var result = comparison.result;
				var bestHand = comparison.hand;
				var cardsToShow = this.getCardsToShow(result, id);
				setTimeout(()=> {
					if (excessWinner) {
						this.interpretResult(result, bestHand, cardsToShow, excess, excessWinner);
					}

					else {
						this.interpretResult(result, bestHand, cardsToShow);
					}
				}, (cardsToDeal.length > 0 ? 2000 : 0)); //allow an extra 2 seconds before emitting result if cards need to be dealt
			}
		}
	}

	public interpretResult(result : number, bestHand: string, cardsToShow, excess? : number, excessWinner? : Player) { //send result and begin new hand
		if (excessWinner && excess) {
			excessWinner.changeStack(excess);
		}
		if (result < 3) {
			var i = result - 1;
			this._players[i].changeStack(this._pot - (excess ? excess : 0));
			this._io.to(this.id).emit('result', {result: 'single winner', id: this._players[i].id, stacks: [this._players[i].stack, this._players[(i+1)%2].stack], cardsToShow: cardsToShow, bestHand: bestHand, nickname: this._players[i].nickname});
		}
		else {
			for (var i=0; i<this._players.length; i++) {
				this._players[i].changeStack((this._pot - (excess ? excess : 0))/ 2); //award half the pot to each player
			}
			this._io.to(this.id).emit('result', {result: 'split pot', id: this._players[0].id, stacks: [this._players[0].stack, this._players[1].stack], cardsToShow: cardsToShow, bestHand: bestHand, nicknames: [this._players[0].nickname, this._players[1].nickname]}); //id of the player with the first stack in the stacks array
		}
		setTimeout(()=> {console.log(this.id); emitter.emit('hand complete' + this.id)}, 8000); //wait before starting new hand
	}

	public handleCheck(id : string) {
		if (id == this._players[this._dealer].id || this._gameStage == 1) { //if the dealer checked or the non-dealer checked after big blind called
			for (var i=0; i<this._players.length; i++) {
				if (id == this._players[i].id) {
					var otherStack = this._players[(i+1)%2].stack;
					var checkedStack = this._players[i].stack;
				}
			}
			if (this._gameStage == 1) {
				for (var i=0; i<this._players.length; i++) { //if bb call followed by a check
					this._players[i].changeStack(this._players[i].bet * -1);
				}
			}
			var cardsToDeal = this.getCardsToDeal();
			this._gameStage += 1;
			this._pot += this._players[0].bet + this._players[1].bet;
			this._table = this._table.concat(cardsToDeal);
			this._io.to(this.id).emit('check', {id: id, checkable: false, pot: this._pot, cards: this.stringifyHand(cardsToDeal), dealer: this._players[this._dealer].id, min: (this._players[(this._dealer + 1) % 2].stack > 20 ? 20 : this._players[(this._dealer + 1) % 2].stack), max: checkedStack, otherMax: otherStack, playingOn: (this._gameStage != 5)});
			this._players[0].bet = 0; //reset bets
			this._players[1].bet = 0;

			if (this._gameStage == 5) {
				var p1Hand = this.stringifyHand(this._players[0].holeCards.concat(this._table));
				var p2Hand = this.stringifyHand(this._players[1].holeCards.concat(this._table));
				var comparison = this.compareHands(p1Hand, p2Hand);
				var result = comparison.result;
				var bestHand = comparison.hand;
				var cardsToShow = this.getCardsToShow(result, id);
				this.interpretResult(comparison.result, comparison.hand, cardsToShow);
			}
		}
		else {
			this._io.to(this.id).emit('check', {id: id, checkable: true});
		}
	}

	public handleFold(id: string) {
		for (var i=0; i<2; i++) {
			if (this._players[i].id != id) {
				this._players[i].changeStack(this._pot);
				this._players[i].changeStack(this._players[(i + 1) % 2].bet); //for any bets haven't been added to pot
				this._players[(i + 1) % 2].changeStack(this._players[(i + 1) % 2].bet * -1);
				var winnerStack = this._players[i].stack;
			}
		}
		this._pot += this._players[0].bet + this._players[1].bet;
		this._io.to(this.id).emit('fold', {pot: this._pot, id: id, winnerStack: winnerStack});
		setTimeout(()=> {emitter.emit('hand complete' + this.id)}, 8000);
	}

	public play() { //add event to emit cards, add max and min bets for slider, evaluate hand, play entire game
		this.newHand();
		emitter.on('call' + this.id, (id)=>{ //using the => syntax so that 'this' refers to the game rather than index
			console.log('game received call');
			this.handleCall(id);
		});

		emitter.on('fold' + this.id, (id)=>{
			console.log('game received fold');
			this.handleFold(id);
		});

		emitter.on('check' + this.id, (id)=>{
			console.log('game received check');
			this.handleCheck(id);
		});

		emitter.on('bet' + this.id, (data)=>{
			console.log('game received bet');
			this.handleBet(data.amount, data.id);
		});

		emitter.on('hand complete' + this.id, ()=>{
			console.log('game received hand complete')
			if (this._players[0].stack != 0 && this._players[1].stack != 0) {
				this.newHand();
			}
			else {
				var winnerID = (this._players[0].stack == 0 ? this._players[1].id : this._players[0].id);
				this._io.to(this.id).emit('game complete', winnerID);
				this.removeEmitterListeners();
				emitter.emit('game complete', this.id);
			}
		});

		emitter.on('disconnect' + this.id, (id)=> {
			console.log(id + " disconnected");
			for (var i=0; i<this._players.length; i++) {
				if (this._players[i].id != id) {
					this._io.to(this._players[i].id).emit('other player disconnected');
				}
			}
			this.removeEmitterListeners();
			emitter.emit('game complete', this.id);
		}); 
	}

	public getCardsToDeal() : number[] {
		var cardsToDeal = [];
		if (this._gameStage < 4) {
			if (this._gameStage > 1) { //turn or river
				cardsToDeal.push(this.getRandomCard());
			}
			else {
				for (var i=0; i<3; i++) { //flop
					cardsToDeal.push(this.getRandomCard());
				}
			}
		}
		return cardsToDeal;
	}

	public getCardsAllIn() : number[] {
		var cardsToDeal = [];
		if (this._gameStage == 1) {
			for (var i=0; i<5; i++) {
				cardsToDeal.push(this.getRandomCard());
			}
		}
		else {
			for (var i=0; i<4-this._gameStage; i++) {
				cardsToDeal.push(this.getRandomCard());
			}

		}
		return cardsToDeal;
	}

	public getCardsToShow(result: number, id : string) {
		var cardsToShow = {};
		if (result != 3) {
			if (this._players[result - 1].id != id) { //if winner to show first
				cardsToShow[id] = this.stringifyHand(this._players[result - 1].holeCards);
			}
			else {
				cardsToShow[this._players[result - 1].id] = this.stringifyHand(this._players[result % 2].holeCards);
				cardsToShow[this._players[result % 2].id] = this.stringifyHand(this._players[result - 1].holeCards);
			}
		}
		else {
			cardsToShow[this._players[0].id] = this.stringifyHand(this._players[1].holeCards);
			cardsToShow[this._players[1].id] = this.stringifyHand(this._players[0].holeCards);
		}
		return cardsToShow;
	}

	public removeEmitterListeners() {
		var gameEvents = ['call', 'check', 'fold', 'bet', 'hand complete', 'disconnect'];
		for (var i=0; i<gameEvents.length; i++) {
			emitter.removeAllListeners(gameEvents[i] + this.id);
		}
	}
}